# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Build pedigrees from (individuals in) a population.
#' 
#' In a newly simulated population, each individual only knows its mother and children. 
#' Using this information, this function builds pedigrees.
#' 
#' @param population Population generated by \code{\link{sample_mtdna_geneology_varying_size}}.
#' @param progress Show progress.
#' 
#' @return An object with class \code{mitolina_pedigreelist} (a list of external pointers to pedigrees).
#' 
#' @export
build_pedigrees <- function(population, progress = TRUE) {
    .Call('_mitolina_build_pedigrees', PACKAGE = 'mitolina', population, progress)
}

#' Simulate a geneology with varying population size.
#' 
#' This function simulates a geneology with varying population size specified
#' by a vector of population sizes, one for each generation. 
#' 
#' By the backwards simulating process of the Wright-Fisher model, 
#' individuals with no descendants in the end population are not simulated 
#' If for some reason additional full generations should be simulated, 
#' the number can be specified via the `generations_full` parameter.
#' This can for example be useful if one wants to simulate the 
#' final 3 generations although some of these may not get (male) children.
#' 
#' Let \eqn{\alpha} be the parameter of a symmetric Dirichlet distribution 
#' specifying each man's probability to be the mother of an arbitrary 
#' male in the next generation. When \eqn{\alpha = 5}, a man's relative probability 
#' to be the mother has 95\% probability to lie between 0.32 and 2.05, compared with a 
#' constant 1 under the standard Wright-Fisher model and the standard deviation in 
#' the number of male offspring per man is 1.10 (standard Wright-Fisher = 1).
#' 
#' This symmetric Dirichlet distribution is implemented by drawing 
#' mother (unscaled) probabilities from a Gamma distribution with 
#' parameters `gamma_parameter_shape` and `gamma_parameter_scale`
#' that are then normalised to sum to 1. 
#' To obtain a symmetric Dirichlet distribution with parameter \eqn{\alpha}, 
#' the following must be used:
#' \eqn{`gamma_parameter_shape` = \alpha}
#' and 
#' \eqn{`gamma_parameter_scale` = 1/\alpha}.
#' 
#' @param population_sizes_females The size of the female population at each generation, `g`. All >= 1.
#'        `population_sizes_females[g]` is the population size at generation `g`.
#'        The length of population_sizes_females is the number of generations being simulated.
#' @param population_sizes_males The size of the male population at each generation, `g`. All >= 0.
#'        `population_sizes_males[g]` is the population size at generation `g`.
#' @param generations_full Number of full generations to be simulated.
#' @param generations_return How many generations to return (pointers to) individuals for.
#' @param enable_gamma_variance_extension Enable symmetric Dirichlet (and disable standard Wright-Fisher).
#' @param gamma_parameter_shape Parameter related to symmetric Dirichlet distribution for each man's probability to be mother. Refer to details.
#' @param gamma_parameter_scale Parameter realted to symmetric Dirichlet distribution for each man's probability to be mother. Refer to details.
#' @param progress Show progress.
#' 
#' @return A `mitolina_simulation` / list with the following entries:
#' \itemize{
#'   \item `population`. An external pointer to the population.
#'   \item `generations`. Generations actually simulated, mostly useful when parameter `generations = -1`.
#'   \item `founders`. Number of founders after the simulated `generations`.
#'   \item `growth_type`. Growth type model.
#'   \item `sdo_type`. Standard deviation in a man's number of male offspring. StandardWF or GammaVariation depending on `enable_gamma_variance_extension`.
#'   \item `end_generation_female_individuals`. Pointers to female individuals in end generation.
#'   \item `female_individuals_generations`. Pointers to female individuals in last `generations_return` generation (if `generations_return = 3`, then female individuals in the last three generations are returned).
#'   \item `end_generation_male_individuals`. Pointers to male individuals in end generation.
#'   \item `male_individuals_generations`. Pointers to male individuals in last `generations_return` generation (if `generations_return = 3`, then male individuals in the last three generations are returned).
#' }
#' @import Rcpp
#' @import RcppProgress
#' @import RcppArmadillo
#' @export
sample_mtdna_geneology_varying_size <- function(population_sizes_females, population_sizes_males, generations_full = 1L, generations_return = 3L, enable_gamma_variance_extension = FALSE, gamma_parameter_shape = 5.0, gamma_parameter_scale = 1.0/5.0, progress = TRUE) {
    .Call('_mitolina_sample_mtdna_geneology_varying_size', PACKAGE = 'mitolina', population_sizes_females, population_sizes_males, generations_full, generations_return, enable_gamma_variance_extension, gamma_parameter_shape, gamma_parameter_scale, progress)
}

#' Get haplotypes from a vector of pids.
#' 
#' Requires that haplotypes are first populated, e.g. 
#' with [pedigrees_all_populate_haplotypes()] or 
#' [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @param population Population
#' @param pids Vector of pids to get haplotypes for.
#' 
#' @return List of haplotypes where row `i` is the haplotype of `individuals[[i]]`.
#' 
#' @seealso [get_haplotypes_individuals()].
#' 
#' @export
get_haplotypes_pids <- function(population, pids) {
    .Call('_mitolina_get_haplotypes_pids', PACKAGE = 'mitolina', population, pids)
}

#' Get haplotype matrix from list of individuals
#' 
#' Requires that haplotypes are first populated, e.g. 
#' with [pedigrees_all_populate_haplotypes()] or 
#' [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @param individuals Individuals to get haplotypes for.
#' @return List of haplotypes where element `i` is the haplotype of `individuals[[i]]`.
#' 
#' @seealso [get_haplotypes_pids()].
#' 
#' @export
get_haplotypes_individuals <- function(individuals) {
    .Call('_mitolina_get_haplotypes_individuals', PACKAGE = 'mitolina', individuals)
}

#' Is individuals females (or males)
#' 
#' @param individuals Individuals to get sex for.
#' @return Logical vector: true for female, false for male
#' 
#' @export
get_individuals_is_female <- function(individuals) {
    .Call('_mitolina_get_individuals_is_female', PACKAGE = 'mitolina', individuals)
}

#' Is individual female (or male)
#' 
#' @param individual Individual to get sex for.
#' @return Logical: true for female, false for male
#' 
#' @export
get_individual_is_female <- function(individual) {
    .Call('_mitolina_get_individual_is_female', PACKAGE = 'mitolina', individual)
}

#' Populate haplotypes in pedigrees (founder types same for all).
#' 
#' Populate haplotypes from founder and down in all pedigrees.
#' Note, that haplotypes are binary (TRUE/FALSE) and 
#' that all founders get haplotype `rep(FALSE, loci)`.
#' 
#' Note, that pedigrees must first have been inferred by [build_pedigrees()].
#' 
#' @param pedigrees Pedigree list in which to populate haplotypes
#' @param mutation_rates Vector with mutation rates, length `loci`
#' @param progress Show progress
#'
#' @seealso [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @export
pedigrees_all_populate_haplotypes <- function(pedigrees, mutation_rates, progress = TRUE) {
    invisible(.Call('_mitolina_pedigrees_all_populate_haplotypes', PACKAGE = 'mitolina', pedigrees, mutation_rates, progress))
}

#' Populate haplotypes in pedigrees (custom founder types).
#' 
#' Populate haplotypes from founder and down in all pedigrees.
#' All founders get a haplotype from calling the user 
#' provided function `get_founder_haplotype()` that must return a vector of TRUE/FALSE values.
#' 
#' Note, that pedigrees must first have been inferred by [build_pedigrees()].
#' 
#' @param pedigrees Pedigree list in which to populate haplotypes
#' @param mutation_rates Vector with mutation rates
#' @param get_founder_haplotype Function taking no arguments returning a haplotype, i.e. a logical vector (TRUE/FALSE values) of length `length(mutation_rates)`
#' @param progress Show progress
#'
#' @seealso [pedigrees_all_populate_haplotypes()].
#' 
#' @export
pedigrees_all_populate_haplotypes_custom_founders <- function(pedigrees, mutation_rates, get_founder_haplotype = NULL, progress = TRUE) {
    invisible(.Call('_mitolina_pedigrees_all_populate_haplotypes_custom_founders', PACKAGE = 'mitolina', pedigrees, mutation_rates, get_founder_haplotype, progress))
}

#' Get haplotype from an individual
#' 
#' Requires that haplotypes are first populated, e.g. 
#' with [pedigrees_all_populate_haplotypes()] or 
#' [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @param individual Individual to get haplotypes for.
#' @return Haplotype for `individual`.
#' 
#' @seealso [get_haplotypes_individuals()] and [get_haplotypes_pids()].
#' 
#' @export
get_haplotype <- function(individual) {
    .Call('_mitolina_get_haplotype', PACKAGE = 'mitolina', individual)
}

#' Get number of variants in haplotype
#'
#' Number of variants is for example faster when checking for equality or when 
#' summarising (like plotting). If haplotypes do not have same number of variants, they cannot be equal.
#'
#' @param individual Individual to get number of variants for
#'
#' @export
get_haplotype_no_variants <- function(individual) {
    .Call('_mitolina_get_haplotype_no_variants', PACKAGE = 'mitolina', individual)
}

#' Count haplotypes occurrences in list of individuals
#' 
#' Counts the number of types `haplotype` appears in `individuals`.
#' 
#' @param individuals List of individuals to count occurrences in.
#' @param haplotype Haplotype to count occurrences of.
#' 
#' @return Number of times that `haplotype` occurred amongst `individuals`.
#' 
#' @seealso [get_matches_info()], [count_haplotype_occurrences_individuals()].
#' 
#' @export
count_haplotype_occurrences_individuals <- function(individuals, haplotype) {
    .Call('_mitolina_count_haplotype_occurrences_individuals', PACKAGE = 'mitolina', individuals, haplotype)
}

#' Get individuals matching from list of individuals
#' 
#' Get the indvididuals that matches `haplotype` in `individuals`.
#' 
#' @param individuals List of individuals to count occurrences in.
#' @param haplotype Haplotype to count occurrences of.
#' @return List of individuals that matches `haplotype` amongst `individuals`.
#' 
#' @export
get_haplotype_matching_individuals <- function(individuals, haplotype) {
    .Call('_mitolina_get_haplotype_matching_individuals', PACKAGE = 'mitolina', individuals, haplotype)
}

#' Information about matching individuals
#' 
#' Note: This function does not check that individuals in 
#' `matching_indv` actually match.
#'
#' Note: only considering individuals within same pedigree!
#'  
#' This gives detailed information about matching individuals in the pedigree, 
#' e.g. meiotic distances and maximum L0 distance (number of sites they differ) on the path as some of these 
#' matches may have (back)mutations between in between them (but often this will be 0).
#' 
#' @param suspect Individual that others must match the profile of.
#' @param matching_indv List of matching individuals to get information for.
#' 
#' @return Matrix with information about matching individuals. 
#' Columns in order: meioses (meiotic distance to `suspect`), 
#' max_L0 (on the path between the matching individual and `suspect`, 
#' what is the maximum L0 distance between the `suspect`'s profile and the 
#' profiles of the individuals on the path), 
#' pid (pid of matching individual)
#' 
#' @seealso [count_haplotype_occurrences_individuals()] and [count_haplotype_occurrences_pedigree()].
#'
#' @export
get_matches_info <- function(suspect, matching_indv) {
    .Call('_mitolina_get_matches_info', PACKAGE = 'mitolina', suspect, matching_indv)
}

#' Meiotic distance between two individuals
#' 
#' Get the number of meioses between two individuals.
#' Note, that pedigrees must first have been inferred by [build_pedigrees()].
#' 
#' @param ind1 Individual 1
#' @param ind2 Individual 2
#' 
#' @return Number of meioses between `ind1` and `ind2` if they are in the same pedigree, else -1.
#' 
#' @export
meiotic_dist <- function(ind1, ind2) {
    .Call('_mitolina_meiotic_dist', PACKAGE = 'mitolina', ind1, ind2)
}

#' Count haplotypes occurrences in pedigree
#' 
#' Counts the number of types `haplotype` appears in `pedigree`.
#' 
#' @param pedigree Pedigree to count occurrences in.
#' @param haplotype Haplotype to count occurrences of.
#' @param generation_upper_bound_in_result Only consider matches in 
#' generation 0, 1, ... generation_upper_bound_in_result.
#' -1 means disabled, consider all generations.
#' End generation is generation 0.
#' Second last generation is 1. 
#' And so on.
#' 
#' @return Number of times that `haplotype` occurred in `pedigree`.
#' 
#' @seealso [get_matches_info()], [count_haplotype_occurrences_individuals()].
#' 
#' @export
count_haplotype_occurrences_pedigree <- function(pedigree, haplotype, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_count_haplotype_occurrences_pedigree', PACKAGE = 'mitolina', pedigree, haplotype, generation_upper_bound_in_result)
}

#' Convert haplotypes to hashes (integers)
#' 
#' Individuals with the same haplotype will have the same hash (integer)
#' and individuals with different haplotypes will have different hashes (integers).
#' 
#' This can be useful if for example using haplotypes to define groups 
#' and the haplotype itself is not of interest.
#' 
#' @param haplotypes List of haplotypes (list of logical vectors)
#' 
#' @export
haplotypes_to_hashes <- function(haplotypes) {
    .Call('_mitolina_haplotypes_to_hashes', PACKAGE = 'mitolina', haplotypes)
}

#' Build hashmap of haplotypes to individuals
#' 
#' Makes it possible to find all individuals with a certain haplotype.
#' Must be used with e.g. [get_haplotype_matching_individuals_from_hashmap()] 
#' or [print_haplotypes_hashmap()].
#' 
#' @param individuals List of individuals to build hashmap of
#' @param max_load_factor Tuning parameter for hash table
#' @param verbose_interval 0 for no verbose output, e.g. 1,000 for output for every 1000 individual added
#' @return Hashmap with haplotypes as keys and vector of individuals as value
#' 
#' @seealso [get_haplotype_matching_individuals_from_hashmap()] 
#' and [print_haplotypes_hashmap()].
#' 
#' @export
build_haplotypes_hashmap <- function(individuals, max_load_factor = 100, verbose_interval = 0L) {
    .Call('_mitolina_build_haplotypes_hashmap', PACKAGE = 'mitolina', individuals, max_load_factor, verbose_interval)
}

#' Print haplotype hashmap
#' 
#' Print hashmap a haplotypes to individuals made by [build_haplotypes_hashmap()].
#' 
#' @param hashmap Hashmap made by [build_haplotypes_hashmap()]
#' 
#' @seealso [get_haplotype_matching_individuals_from_hashmap()] 
#' and [build_haplotypes_hashmap()].
#' 
#' @export
print_haplotypes_hashmap <- function(hashmap) {
    invisible(.Call('_mitolina_print_haplotypes_hashmap', PACKAGE = 'mitolina', hashmap))
}

#' Get individuals with a certain haplotype by hashmap lookup
#' 
#' By using hashmap made by [build_haplotypes_hashmap()], 
#' it is easy to get all individuals with a certain haplotype.
#' 
#' @param hashmap Hashmap to make lookup in, made by [build_haplotypes_hashmap()]
#' @param haplotype to get individuals that has this haplotype
#' 
#' @return List of individuals with a given haplotype
#' 
#' @seealso [print_haplotypes_hashmap()] 
#' and [build_haplotypes_hashmap()].
#' 
#' @export
get_haplotype_matching_individuals_from_hashmap <- function(hashmap, haplotype) {
    .Call('_mitolina_get_haplotype_matching_individuals_from_hashmap', PACKAGE = 'mitolina', hashmap, haplotype)
}

#' Delete haplotype hashmap
#' 
#' Delete hashmap made by [build_haplotypes_hashmap()].
#' 
#' @param hashmap Hashmap made by [build_haplotypes_hashmap()]
#' 
#' @seealso [get_haplotype_matching_individuals_from_hashmap()] 
#' and [build_haplotypes_hashmap()].
#' 
#' @export
delete_haplotypes_hashmap <- function(hashmap) {
    invisible(.Call('_mitolina_delete_haplotypes_hashmap', PACKAGE = 'mitolina', hashmap))
}

#' Get individual by pid
#' 
#' @param population Population
#' @param pid pid
#' 
#' @return Individual
#' 
#' @export
get_individual <- function(population, pid) {
    .Call('_mitolina_get_individual', PACKAGE = 'mitolina', population, pid)
}

#' Get pid from individual
#' 
#' @param individual Individual to get pid of
#' 
#' @return pid
#' 
#' @export
get_pid <- function(individual) {
    .Call('_mitolina_get_pid', PACKAGE = 'mitolina', individual)
}

#' Print individual
#' 
#' @param individual Individual
#' 
#' @export
print_individual <- function(individual) {
    invisible(.Call('_mitolina_print_individual', PACKAGE = 'mitolina', individual))
}

#' Get individual's generations from final generation
#'
#' @param individual Individual to get number of generations from final generation
#' @return Number of generations from final generation
#' 
#' @export
get_generations_from_final <- function(individual) {
    .Call('_mitolina_get_generations_from_final', PACKAGE = 'mitolina', individual)
}

#' Get pedigree from individual
#' 
#' @param individual Individual
#' 
#' @return pedigree
#' 
#' @export
get_pedigree_from_individual <- function(individual) {
    .Call('_mitolina_get_pedigree_from_individual', PACKAGE = 'mitolina', individual)
}

#' Get pedigree ids from pids
#'
#' @param population Population
#' @param pids Pids
#' 
#' @return Vector with pedigree ids
#' 
#' @export
get_pedigree_id_from_pid <- function(population, pids) {
    .Call('_mitolina_get_pedigree_id_from_pid', PACKAGE = 'mitolina', population, pids)
}

pop_size <- function(population) {
    .Call('_mitolina_pop_size', PACKAGE = 'mitolina', population)
}

#' Get all individuals in population
#' 
#' @param population Population
#'
#' @export
get_individuals <- function(population) {
    .Call('_mitolina_get_individuals', PACKAGE = 'mitolina', population)
}

#' Meiotic distribution
#' 
#' Get the distribution of number of meioses from `individual` 
#' to all individuals in `individual`'s pedigree.
#' Note the `generation_upper_bound_in_result` parameter.
#' 
#' @param individual Individual to calculate all meiotic distances from
#' @param generation_upper_bound_in_result Limit on distribution; -1 means no limit. 
#' 0 is the final generation. 1 second last generation etc.
#' 
#' @export
meioses_generation_distribution <- function(individual, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_meioses_generation_distribution', PACKAGE = 'mitolina', individual, generation_upper_bound_in_result)
}

#' Size of population
#' 
#' Get the size of the population.
#' Note the `generation_upper_bound_in_result` parameter.
#' 
#' @param population Population to get size of
#' @param is_female true to count females, false to count males
#' @param generation_upper_bound_in_result Limit on generation to include in count; -1 means no limit. 
#' 0 only include the final generation. 1 only second last generation etc.
#' 
#' @export
population_size_generation <- function(population, is_female = TRUE, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_population_size_generation', PACKAGE = 'mitolina', population, is_female, generation_upper_bound_in_result)
}

#' Size of pedigree
#' 
#' Get the size of the pedigree.
#' Note the `generation_upper_bound_in_result` parameter.
#' 
#' @param pedigree Pedigree to get size of
#' @param is_female true to count females, false to count males
#' @param generation_upper_bound_in_result Limit on generation to include in count; -1 means no limit. 
#' 0 only include the final generation. 1 only second last generation etc.
#' 
#' @export
pedigree_size_generation <- function(pedigree, is_female = TRUE, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_pedigree_size_generation', PACKAGE = 'mitolina', pedigree, is_female, generation_upper_bound_in_result)
}

#' Get pedigree id
#' 
#' @param ped Pedigree
#' 
#' @export
get_pedigree_id <- function(ped) {
    .Call('_mitolina_get_pedigree_id', PACKAGE = 'mitolina', ped)
}

#' Get number of pedigrees
#' 
#' @param pedigrees Pedigrees
#' 
#' @export
pedigrees_count <- function(pedigrees) {
    .Call('_mitolina_pedigrees_count', PACKAGE = 'mitolina', pedigrees)
}

#' Get pedigree size
#' 
#' @param ped Pedigree
#' 
#' @export
pedigree_size <- function(ped) {
    .Call('_mitolina_pedigree_size', PACKAGE = 'mitolina', ped)
}

#' Get distribution of pedigree sizes
#' 
#' @param pedigrees Pedigrees
#' 
#' @export
pedigrees_table <- function(pedigrees) {
    .Call('_mitolina_pedigrees_table', PACKAGE = 'mitolina', pedigrees)
}

print_pedigree <- function(ped) {
    invisible(.Call('_mitolina_print_pedigree', PACKAGE = 'mitolina', ped))
}

#' Get pids in pedigree
#' 
#' @param ped Pedigree
#' 
#' @export
get_pids_in_pedigree <- function(ped) {
    .Call('_mitolina_get_pids_in_pedigree', PACKAGE = 'mitolina', ped)
}

#' Get sexes of individuals in pedigree
#' 
#' @param ped Pedigree to get sexes for
#' @return `TRUE` if female, `FALSE` if male
#' 
#' @export
get_is_female_in_pedigree <- function(ped) {
    .Call('_mitolina_get_is_female_in_pedigree', PACKAGE = 'mitolina', ped)
}

#' Get haplotypes in pedigree
#' 
#' @param ped Pedigree to get haplotypes for
#' @return List with haplotypes
#' 
#' @export
get_haplotypes_in_pedigree <- function(ped) {
    .Call('_mitolina_get_haplotypes_in_pedigree', PACKAGE = 'mitolina', ped)
}

get_pedigree_edgelist <- function(ped) {
    .Call('_mitolina_get_pedigree_edgelist', PACKAGE = 'mitolina', ped)
}

#' Get pedigree information as graph (mainly intended for plotting)
#' 
#' @param ped Pedigree to get as graph
#' 
#' @export
get_pedigree_as_graph <- function(ped) {
    .Call('_mitolina_get_pedigree_as_graph', PACKAGE = 'mitolina', ped)
}

#' Get pedigrees information in tidy format
#' 
#' @param pedigrees Pedigrees
#' 
get_pedigrees_tidy <- function(pedigrees) {
    .Call('_mitolina_get_pedigrees_tidy', PACKAGE = 'mitolina', pedigrees)
}

#' Generate test population
#' 
#' @return An external pointer to the population.
test_create_population <- function() {
    .Call('_mitolina_test_create_population', PACKAGE = 'mitolina')
}

