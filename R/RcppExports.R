# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

wipe_pedigrees <- function(pedigrees) {
    invisible(.Call('_mitolina_wipe_pedigrees', PACKAGE = 'mitolina', pedigrees))
}

#' Build pedigrees from (individuals in) a population.
#' 
#' In a newly simulated population, each individual only knows its mother and children. 
#' Using this information, this function builds pedigrees.
#' 
#' @param population Population generated by \code{\link{sample_mtdna_geneology_varying_size}}.
#' @param progress Show progress.
#' 
#' @return An object with class \code{mitolina_pedigreelist} (an internal list of external pointers to pedigrees).
#' 
#' @export
build_pedigrees <- function(population, progress = TRUE) {
    .Call('_mitolina_build_pedigrees', PACKAGE = 'mitolina', population, progress)
}

#' Simulate a geneology with varying population size.
#' 
#' This function simulates a geneology with varying population size specified
#' by a vector of population sizes, one for each generation. 
#' 
#' By the backwards simulating process of the Wright-Fisher model, 
#' individuals with no descendants in the end population are not simulated 
#' If for some reason additional full generations should be simulated, 
#' the number can be specified via the `extra_generations_full` parameter.
#' This can for example be useful if one wants to simulate the 
#' final 3 generations although some of these may not get (male) children.
#' 
#' Let \eqn{\alpha} be the parameter of a symmetric Dirichlet distribution 
#' specifying each man's probability to be the mother of an arbitrary 
#' male in the next generation. When \eqn{\alpha = 5}, a man's relative probability 
#' to be the mother has 95\% probability to lie between 0.32 and 2.05, compared with a 
#' constant 1 under the standard Wright-Fisher model and the standard deviation in 
#' the number of male offspring per man is 1.10 (standard Wright-Fisher = 1).
#' 
#' This symmetric Dirichlet distribution is implemented by drawing 
#' mother (unscaled) probabilities from a Gamma distribution with 
#' parameters `gamma_parameter_shape` and `gamma_parameter_scale`
#' that are then normalised to sum to 1. 
#' To obtain a symmetric Dirichlet distribution with parameter \eqn{\alpha}, 
#' the following must be used:
#' \eqn{`gamma_parameter_shape` = \alpha}
#' and 
#' \eqn{`gamma_parameter_scale` = 1/\alpha}.
#' 
#' @param population_sizes_females The size of the female population at each generation, g. All >= 1.
#'        population_sizes_females[g] is the population size at generation g.
#'        The length of population_sizes_females is the number of generations being simulated.
#' @param population_sizes_males The size of the male population at each generation, g. All >= 0.
#'        population_sizes_males[g] is the population size at generation g.
#' @param extra_generations_full Additional full generations to be simulated.
#' @param gamma_parameter_shape Parameter related to symmetric Dirichlet distribution for each man's probability to be mother. Refer to details.
#' @param gamma_parameter_scale Parameter realted to symmetric Dirichlet distribution for each man's probability to be mother. Refer to details.
#' @param enable_gamma_variance_extension Enable symmetric Dirichlet (and disable standard Wright-Fisher).
#' @param progress Show progress.
#' @param extra_individuals_generations_return How many generations back to return (pointers to) individuals for in addition to the end population?
#' 
#' @return A `mitolina_simulation` / list with the following entries:
#' \itemize{
#'   \item `population`. An external pointer to the population.
#'   \item `generations`. Generations actually simulated, mostly useful when parameter `generations = -1`.
#'   \item `founders`. Number of founders after the simulated `generations`.
#'   \item `growth_type`. Growth type model.
#'   \item `sdo_type`. Standard deviation in a man's number of male offspring. StandardWF or GammaVariation depending on `enable_gamma_variance_extension`.
#'   \item `end_generation_female_individuals`. Pointers to female individuals in end generation.
#'   \item `female_individuals_generations`. Pointers to female individuals in end generation in addition to the previous `extra_individuals_generations_return`.
#'   \item `end_generation_male_individuals`. Pointers to male individuals in end generation.
#'   \item `male_individuals_generations`. Pointers to male individuals in end generation in addition to the previous `extra_individuals_generations_return`.
#' }
#' @import Rcpp
#' @import RcppProgress
#' @import RcppArmadillo
#' @export
sample_mtdna_geneology_varying_size <- function(population_sizes_females, population_sizes_males, extra_generations_full = 0L, gamma_parameter_shape = 5.0, gamma_parameter_scale = 1.0/5.0, enable_gamma_variance_extension = FALSE, progress = TRUE, extra_individuals_generations_return = 2L) {
    .Call('_mitolina_sample_mtdna_geneology_varying_size', PACKAGE = 'mitolina', population_sizes_females, population_sizes_males, extra_generations_full, gamma_parameter_shape, gamma_parameter_scale, enable_gamma_variance_extension, progress, extra_individuals_generations_return)
}

#' Get haplotypes from a vector of pids.
#' 
#' Requires that haplotypes are first populated, e.g. 
#' with [pedigrees_all_populate_haplotypes()] or 
#' [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @param population Population
#' @param pids Vector of pids to get haplotypes for.
#' 
#' @return List of haplotypes where row `i` is the haplotype of `individuals[[i]]`.
#' 
#' @seealso [get_haplotypes_individuals()].
#' 
#' @export
get_haplotypes_pids <- function(population, pids) {
    .Call('_mitolina_get_haplotypes_pids', PACKAGE = 'mitolina', population, pids)
}

#' Get haplotype matrix from list of individuals
#' 
#' Requires that haplotypes are first populated, e.g. 
#' with [pedigrees_all_populate_haplotypes()] or 
#' [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @param individuals Individuals to get haplotypes for.
#' @return Matrix of haplotypes where row `i` is the haplotype of `individuals[[i]]`.
#' 
#' @seealso [get_haplotypes_pids()].
#' 
#' @export
get_haplotypes_individuals <- function(individuals) {
    .Call('_mitolina_get_haplotypes_individuals', PACKAGE = 'mitolina', individuals)
}

#' Is individuals females (or males)
#' 
#' @param individuals Individuals to get haplotypes for.
#' @return Logical vector: true for female, false for male
#' 
#' @export
get_individuals_is_female <- function(individuals) {
    .Call('_mitolina_get_individuals_is_female', PACKAGE = 'mitolina', individuals)
}

#' @export
pedigree_populate_haplotypes <- function(ped, loci, mutation_rates) {
    invisible(.Call('_mitolina_pedigree_populate_haplotypes', PACKAGE = 'mitolina', ped, loci, mutation_rates))
}

#' Populate haplotypes in pedigrees (founder types same for all).
#' 
#' Populate haplotypes from founder and down in all pedigrees.
#' Note, that haplotypes are binary (TRUE/FALSE) and 
#' that all founders get haplotype `rep(FALSE, loci)`.
#' 
#' Note, that pedigrees must first have been inferred by [build_pedigrees()].
#' 
#' @param pedigrees Pedigree list in which to populate haplotypes
#' @param loci Number of loci
#' @param mutation_rates Vector with mutation rates, length `loci`
#' @param progress Show progress
#'
#' @seealso [pedigrees_all_populate_haplotypes_custom_founders()].
#' 
#' @export
pedigrees_all_populate_haplotypes <- function(pedigrees, mutation_rates, progress = TRUE) {
    invisible(.Call('_mitolina_pedigrees_all_populate_haplotypes', PACKAGE = 'mitolina', pedigrees, mutation_rates, progress))
}

#' Populate haplotypes in pedigrees (custom founder types).
#' 
#' Populate haplotypes from founder and down in all pedigrees.
#' All founders get a haplotype from calling the user 
#' provided function `get_founder_haplotype()` that must return a vector of TRUE/FALSE values.
#' 
#' Note, that pedigrees must first have been inferred by [build_pedigrees()].
#' 
#' @param pedigrees Pedigree list in which to populate haplotypes
#' @param mutation_rates Vector with mutation rates
#' @param get_founder_haplotype Function taking no arguments returning a haplotype, i.e. a logical vector (TRUE/FALSE values) of length `length(mutation_rates)`
#' @param progress Show progress
#'
#' @seealso [pedigrees_all_populate_haplotypes()].
#' 
#' @export
pedigrees_all_populate_haplotypes_custom_founders <- function(pedigrees, mutation_rates, get_founder_haplotype = NULL, progress = TRUE) {
    invisible(.Call('_mitolina_pedigrees_all_populate_haplotypes_custom_founders', PACKAGE = 'mitolina', pedigrees, mutation_rates, get_founder_haplotype, progress))
}

#' @export
get_haplotype <- function(individual) {
    .Call('_mitolina_get_haplotype', PACKAGE = 'mitolina', individual)
}

#' @export
get_haplotype_no_variants <- function(individual) {
    .Call('_mitolina_get_haplotype_no_variants', PACKAGE = 'mitolina', individual)
}

#' @export
count_haplotype_occurrences_individuals <- function(individuals, haplotype) {
    .Call('_mitolina_count_haplotype_occurrences_individuals', PACKAGE = 'mitolina', individuals, haplotype)
}

#' Get individuals matching from list of individuals
#' 
#' Get the indvididuals that matches `haplotype` in `individuals`.
#' 
#' @param individuals List of individuals to count occurrences in.
#' @param haplotype Haplotype to count occurrences of.
#' @return List of individuals that matches `haplotype` amongst `individuals`.
#' 
#' @export
get_haplotype_matching_individuals <- function(individuals, haplotype) {
    .Call('_mitolina_get_haplotype_matching_individuals', PACKAGE = 'mitolina', individuals, haplotype)
}

#' @export
get_matches_info <- function(suspect, matching_indv) {
    .Call('_mitolina_get_matches_info', PACKAGE = 'mitolina', suspect, matching_indv)
}

#' @export
meiotic_dist <- function(ind1, ind2) {
    .Call('_mitolina_meiotic_dist', PACKAGE = 'mitolina', ind1, ind2)
}

#' @export
count_haplotype_occurrences_pedigree <- function(pedigree, haplotype, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_count_haplotype_occurrences_pedigree', PACKAGE = 'mitolina', pedigree, haplotype, generation_upper_bound_in_result)
}

#' @export
haplotypes_to_hashes <- function(haplotypes) {
    .Call('_mitolina_haplotypes_to_hashes', PACKAGE = 'mitolina', haplotypes)
}

#' @export
build_haplotypes_hashmap <- function(individuals) {
    .Call('_mitolina_build_haplotypes_hashmap', PACKAGE = 'mitolina', individuals)
}

#' @export
print_haplotypes_hashmap <- function(hashmap) {
    invisible(.Call('_mitolina_print_haplotypes_hashmap', PACKAGE = 'mitolina', hashmap))
}

#' @export
get_haplotype_matching_individuals_from_hashmap <- function(hashmap, haplotype) {
    .Call('_mitolina_get_haplotype_matching_individuals_from_hashmap', PACKAGE = 'mitolina', hashmap, haplotype)
}

#' @export
get_individual <- function(population, pid) {
    .Call('_mitolina_get_individual', PACKAGE = 'mitolina', population, pid)
}

#' @export
get_pid <- function(individual) {
    .Call('_mitolina_get_pid', PACKAGE = 'mitolina', individual)
}

#' @export
print_individual <- function(individual) {
    invisible(.Call('_mitolina_print_individual', PACKAGE = 'mitolina', individual))
}

#' Get individual's generations
#' 
#' @export
get_generations_from_final <- function(individual) {
    .Call('_mitolina_get_generations_from_final', PACKAGE = 'mitolina', individual)
}

#' Get pedigree from individual
#' 
#' @export
get_pedigree_from_individual <- function(individual) {
    .Call('_mitolina_get_pedigree_from_individual', PACKAGE = 'mitolina', individual)
}

#' Get pedigree id from pid
#' 
#' @export
get_pedigree_id_from_pid <- function(population, pids) {
    .Call('_mitolina_get_pedigree_id_from_pid', PACKAGE = 'mitolina', population, pids)
}

pop_size <- function(population) {
    .Call('_mitolina_pop_size', PACKAGE = 'mitolina', population)
}

#' Get all individuals in population
#' 
#' @param population Population
#'
#' @export
get_individuals <- function(population) {
    .Call('_mitolina_get_individuals', PACKAGE = 'mitolina', population)
}

#' Meiotic distribution
#' 
#' Get the distribution of number of meioses from `individual` 
#' to all individuals in `individual`'s pedigree.
#' Note the `generation_upper_bound_in_result` parameter.
#' 
#' @param individual Individual to calculate all meiotic distances from
#' @param generation_upper_bound_in_result Limit on distribution; -1 means no limit. 
#' 0 is the final generation. 1 second last generation etc.
#' 
#' @export
meioses_generation_distribution <- function(individual, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_meioses_generation_distribution', PACKAGE = 'mitolina', individual, generation_upper_bound_in_result)
}

#' Size of population
#' 
#' Get the size of the population.
#' Note the `generation_upper_bound_in_result` parameter.
#' 
#' @param population Population to get size of
#' @param generation_upper_bound_in_result Limit on generation to include in count; -1 means no limit. 
#' 0 only include the final generation. 1 only second last generation etc.
#' 
#' @export
population_size_generation <- function(population, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_population_size_generation', PACKAGE = 'mitolina', population, generation_upper_bound_in_result)
}

#' Size of pedigree
#' 
#' Get the size of the pedigree.
#' Note the `generation_upper_bound_in_result` parameter.
#' 
#' @param pedigree Pedigree to get size of
#' @param generation_upper_bound_in_result Limit on generation to include in count; -1 means no limit. 
#' 0 only include the final generation. 1 only second last generation etc.
#' 
#' @export
pedigree_size_generation <- function(pedigree, generation_upper_bound_in_result = -1L) {
    .Call('_mitolina_pedigree_size_generation', PACKAGE = 'mitolina', pedigree, generation_upper_bound_in_result)
}

#' Get pedigree id
#' 
#' @export
get_pedigree_id <- function(ped) {
    .Call('_mitolina_get_pedigree_id', PACKAGE = 'mitolina', ped)
}

#' Get number of pedigrees
#' 
#' @export
pedigrees_count <- function(pedigrees) {
    .Call('_mitolina_pedigrees_count', PACKAGE = 'mitolina', pedigrees)
}

#' Get pedigree size
#' 
#' @export
pedigree_size <- function(ped) {
    .Call('_mitolina_pedigree_size', PACKAGE = 'mitolina', ped)
}

#' Get distribution of pedigree sizes
#' 
#' @export
pedigrees_table <- function(pedigrees) {
    .Call('_mitolina_pedigrees_table', PACKAGE = 'mitolina', pedigrees)
}

get_pedigree <- function(pedigrees, index) {
    .Call('_mitolina_get_pedigree', PACKAGE = 'mitolina', pedigrees, index)
}

print_pedigree <- function(ped) {
    invisible(.Call('_mitolina_print_pedigree', PACKAGE = 'mitolina', ped))
}

#' get pids in pedigree
#' 
#' @export
get_pids_in_pedigree <- function(ped) {
    .Call('_mitolina_get_pids_in_pedigree', PACKAGE = 'mitolina', ped)
}

#' get genders in pedigree
#' 
#' @export
get_is_female_in_pedigree <- function(ped) {
    .Call('_mitolina_get_is_female_in_pedigree', PACKAGE = 'mitolina', ped)
}

#' get pids in pedigree
#' 
#' @export
get_haplotypes_in_pedigree <- function(ped) {
    .Call('_mitolina_get_haplotypes_in_pedigree', PACKAGE = 'mitolina', ped)
}

get_pedigree_edgelist <- function(ped) {
    .Call('_mitolina_get_pedigree_edgelist', PACKAGE = 'mitolina', ped)
}

#' Get pedigree information as graph (mainly intended for plotting)
#' 
#' @export
get_pedigree_as_graph <- function(ped) {
    .Call('_mitolina_get_pedigree_as_graph', PACKAGE = 'mitolina', ped)
}

#' get pedigrees information in tidy format
#' 
get_pedigrees_tidy <- function(pedigrees) {
    .Call('_mitolina_get_pedigrees_tidy', PACKAGE = 'mitolina', pedigrees)
}

#' Generate test population
#' 
#' @return An external pointer to the population.
test_create_population <- function() {
    .Call('_mitolina_test_create_population', PACKAGE = 'mitolina')
}

