#include <RcppArmadillo.h>

// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>

#include "mitolina_types.h"

using namespace Rcpp;

/*
// [[Rcpp::export]]
void wipe_pedigrees(Rcpp::List pedigrees) {
  
  std::vector<Pedigree*>* peds = pedigrees;
  
  for (auto it = pedigrees->begin(); it != pedigrees->end(); ++it) {
    delete *it;
  }
  
  delete peds;
}
*/

/*
bool pedigree_size_comparator(Pedigree* p1, Pedigree* p2) { 
  return (p1->get_all_individuals()->size() > p2->get_all_individuals()->size());
}
*/

//' Build pedigrees from (individuals in) a population.
//' 
//' In a newly simulated population, each individual only knows its mother and children. 
//' Using this information, this function builds pedigrees.
//' 
//' @param population Population generated by \code{\link{sample_mtdna_geneology_varying_size}}.
//' @param progress Show progress.
//' 
//' @return An object with class \code{mitolina_pedigreelist} (a list of external pointers to pedigrees).
//' 
//' @export
// [[Rcpp::export]]
Rcpp::List build_pedigrees(Rcpp::XPtr<Population> population, bool progress = true) {
  std::unordered_map<int, Individual*> pop = *(population->get_population());
  
  // Check if peds are already built ->  
  for (auto it = pop.begin(); it != pop.end(); ++it) {
    if (it->second == nullptr) {
      continue;
    }
    
    if (it->second->pedigree_is_set()) {
      Rcpp::stop("It looks like pedigrees are already built for this population, so will not do it again.");
    }
    
    break;
  }
  // <- Check if peds are already built

  // Construct pedigrees
  Rcpp::List pedigrees;
  
  int pedigree_id = 1;
  Pedigree* ped;
  
  int N = pop.size();
  int k = 0;
  Progress p(N, progress);

  ped = new Pedigree(pedigree_id);
  
  for (auto it = pop.begin(); it != pop.end(); ++it) {
    if (it->second->pedigree_is_set()) {
      continue;
    }
    
    int ped_size = 0;
    
    // Recursively assigns children
    it->second->set_pedigree_id(pedigree_id, ped, &ped_size);

    pedigree_id += 1;

    Rcpp::XPtr<Pedigree> ped_res(ped, false); // do NOT delete pedigree when not used any more, it still exists in list of pedigrees etc.!
    ped_res.attr("class") = Rcpp::CharacterVector::create("mitolina_pedigree", "externalptr");
    pedigrees.push_back(ped_res);
    
    ped = new Pedigree(pedigree_id);
    
    if (k % CHECK_ABORT_EVERY == 0 && Progress::check_abort() ) {
      stop("Aborted");
    }
    
    if (progress) {
      p.increment();
    }
    
    ++k;
  }
  
  if (ped->get_all_individuals()->size() > 0) {
    Rcpp::XPtr<Pedigree> ped_res(ped, false); // do NOT delete pedigree when not used any more, it still exists in list of pedigrees etc.!
    ped_res.attr("class") = Rcpp::CharacterVector::create("mitolina_pedigree", "externalptr");
    pedigrees.push_back(ped_res);
  } else {
    delete ped;
  }
  
  pedigrees.attr("class") = CharacterVector::create("mitolina_pedigreelist", "list");

  //std::sort(pedigrees->begin(), pedigrees->end(), pedigree_size_comparator);
  
  return pedigrees;
}


